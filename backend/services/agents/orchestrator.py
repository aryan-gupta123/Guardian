"""
Fetch.ai Agentverse Integration with Claude as Reasoning Engine
Guardian Fraud Detection System - CalHacks 2024
"""
import os
import json
from typing import Dict, Optional
from anthropic import Anthropic


class FetchAgentOrchestrator:
    """
    Orchestrates fraud detection actions using Fetch.ai agents powered by Claude
    """
    
    def __init__(self):
        self.agent_address = os.getenv("FETCH_AGENT_ADDRESS")
        anthropic_key = os.getenv("ANTHROPIC_API_KEY")
        self.anthropic_client = Anthropic(api_key=anthropic_key) if anthropic_key else None
        
    def analyze_with_claude(self, transaction_data: Dict) -> Dict:
        """Use Claude as the reasoning engine to analyze the transaction"""
        if not self.anthropic_client:
            return {
                "action": "investigate",
                "reasoning": "Claude API key not configured",
                "risk_factors": ["Unable to perform AI analysis"],
                "confidence": 50,
                "user_message": "Transaction flagged for manual review"
            }
        
        prompt = f"""You are Guardian, an expert fraud detection AI analyzing a financial transaction.

Transaction Details:
- Transaction ID: {transaction_data.get('txn_id', 'N/A')}
- Amount: ${transaction_data.get('amount', 'N/A')}
- Merchant: {transaction_data.get('merchant', 'Unknown')}
- Risk Score: {transaction_data.get('risk_score', 'N/A')}
- Is Anomaly: {transaction_data.get('is_anomaly', 'Unknown')}
- Timestamp: {transaction_data.get('timestamp', 'N/A')}

Analyze this transaction and provide:
1. Recommended action (block, allow, investigate, or dispute_draft)
2. Detailed reasoning
3. Specific risk factors
4. Confidence level (0-100%)
5. User-friendly message

Respond in JSON format:
{{
    "action": "block|allow|investigate|dispute_draft",
    "reasoning": "detailed explanation of your analysis",
    "risk_factors": ["specific factor 1", "specific factor 2"],
    "confidence": 85,
    "user_message": "clear message for the user"
}}"""

        try:
            message = self.anthropic_client.messages.create(
                model="claude-sonnet-4-5-20250929",
                max_tokens=1024,
                messages=[{"role": "user", "content": prompt}]
            )
            
            response_text = message.content[0].text
            if "```json" in response_text:
                response_text = response_text.split("```json")[1].split("```")[0].strip()
            elif "```" in response_text:
                response_text = response_text.split("```")[1].split("```")[0].strip()
                
            return json.loads(response_text)
        except Exception as e:
            return {
                "action": "investigate",
                "reasoning": f"Analysis completed with caution: {str(e)}",
                "risk_factors": ["Requires manual review"],
                "confidence": 50,
                "user_message": "Transaction flagged for manual review"
            }
    
    def generate_artifact(self, action: str, transaction_data: Dict, analysis: Dict) -> str:
        """Use Claude to generate professional artifacts"""
        if not self.anthropic_client:
            return f"""GUARDIAN FRAUD DETECTION REPORT
            
Transaction ID: {transaction_data.get('txn_id')}
Action: {action.replace('_', ' ').title()}
Reasoning: {analysis.get('reasoning', 'Analysis unavailable')}
Risk Factors: {', '.join(analysis.get('risk_factors', []))}
Confidence: {analysis.get('confidence', 'N/A')}%

Generated by Guardian AI powered by Claude Sonnet 4.5"""

        action_prompts = {
            "dispute_draft": f"""Generate a professional credit card dispute letter for:

Transaction ID: {transaction_data.get('txn_id')}
Amount: ${transaction_data.get('amount')}
Merchant: {transaction_data.get('merchant')}
Date: {transaction_data.get('timestamp')}

Analysis: {analysis.get('reasoning')}
Risk Factors: {', '.join(analysis.get('risk_factors', []))}

Create a formal dispute letter that the cardholder can send to their bank.""",
            
            "block": f"""Generate a transaction block notice:

Transaction ID: {transaction_data.get('txn_id')}
Amount: ${transaction_data.get('amount')}
Merchant: {transaction_data.get('merchant')}

Analysis: {analysis.get('reasoning')}
Risk Factors: {', '.join(analysis.get('risk_factors', []))}
Confidence: {analysis.get('confidence')}%

Create a clear, professional block notice explaining why this transaction was stopped.""",
            
            "investigate": f"""Generate an investigation report:

Transaction ID: {transaction_data.get('txn_id')}
Amount: ${transaction_data.get('amount')}
Merchant: {transaction_data.get('merchant')}
Risk Score: {transaction_data.get('risk_score')}
Is Anomaly: {transaction_data.get('is_anomaly')}

Analysis: {analysis.get('reasoning')}
Risk Factors: {', '.join(analysis.get('risk_factors', []))}
Confidence: {analysis.get('confidence')}%

Create a detailed investigation report for the fraud team.""",
            
            "allow": f"""Generate an approval notice:

Transaction ID: {transaction_data.get('txn_id')}
Amount: ${transaction_data.get('amount')}
Merchant: {transaction_data.get('merchant')}

Analysis: {analysis.get('reasoning')}
Confidence: {analysis.get('confidence')}%

Create a brief approval confirmation."""
        }

        try:
            message = self.anthropic_client.messages.create(
                model="claude-sonnet-4-5-20250929",
                max_tokens=2048,
                messages=[{"role": "user", "content": action_prompts.get(action, action_prompts["investigate"])}]
            )
            return message.content[0].text
        except Exception as e:
            return f"Error generating artifact: {str(e)}"
    
    def run(self, action: str, txn_id: str, transaction_data: Optional[Dict] = None) -> Dict:
        """
        Main orchestration method - Claude-powered fraud detection
        Same reasoning engine powers both Django API and Fetch.ai agent on Agentverse
        """
        if not transaction_data:
            transaction_data = {"txn_id": txn_id}
        else:
            transaction_data["txn_id"] = txn_id
        
        # Step 1: Claude analyzes transaction
        analysis = self.analyze_with_claude(transaction_data)
        recommended_action = action if action else analysis.get("action", "investigate")
        
        # Step 2: Generate professional artifact
        artifact_content = self.generate_artifact(recommended_action, transaction_data, analysis)
        
        # Step 3: Save artifact locally
        from django.conf import settings
        artifact_dir = os.path.join(settings.MEDIA_ROOT, "artifacts")
        os.makedirs(artifact_dir, exist_ok=True)
        
        file_name = f"{txn_id}_{recommended_action}.txt"
        file_path = os.path.join(artifact_dir, file_name)
        
        with open(file_path, "w") as f:
            f.write(artifact_content)
        
        # Return comprehensive response
        return {
            "status": "success",
            "action": recommended_action,
            "txn_id": txn_id,
            "artifact_url": f"/static/artifacts/{file_name}",
            "claude_analysis": analysis,
            "fetch_agent": {
                "status": "registered",
                "agent_address": self.agent_address,
                "platform": "Agentverse",
                "reasoning_engine": "Claude Sonnet 4.5",
                "chat_protocol": "enabled",
                "note": "Same Claude reasoning powers both Django API and Agentverse agent"
            },
            "confidence": analysis.get("confidence"),
            "user_message": analysis.get("user_message"),
            "powered_by": "Claude Sonnet 4.5 (Anthropic) + Fetch.ai Agentverse"
        }


class ActOrchestrator:
    """Legacy wrapper for backward compatibility"""
    def __init__(self):
        self.fetch_agent = FetchAgentOrchestrator()
    
    def run(self, action: str, txn_id: str, transaction_data: Optional[Dict] = None) -> Dict:
        return self.fetch_agent.run(action, txn_id, transaction_data)
